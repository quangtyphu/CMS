<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Dashboard LC79</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --blue:#3498db; --green:#2ecc71; --red:#e74c3c; --gray:#f7f8fa; }
    body{font-family:Arial, sans-serif; background:var(--gray); margin:0; padding:20px;}
    h2{margin:0 0 12px;}
    button{padding:4px 8px; border:none; border-radius:4px; background:var(--blue); color:#fff; cursor:pointer; font-size:12px;}
    button:hover{background:#2980b9;}
    .cancel-btn{background:var(--red);} .cancel-btn:hover{background:#c0392b;}
    table{width:100%; border-collapse:collapse; background:#fff; border-radius:10px; overflow:hidden;}
    th, td{border:1px solid #eee; padding:8px; text-align:center; font-size:14px;}
    th{background:var(--blue); color:#fff; position:sticky; top:0; z-index:1;}
    .muted{color:#888;}
    .editable-device{border-bottom:1px dashed var(--blue); color:var(--blue); cursor:pointer; display:inline-block; min-width:60px;}
    .editable-input{width:120px; text-align:center;}
    .status-select.playing{background:var(--green); color:#fff; font-weight:bold;}
    .status-select.done{background:var(--red); color:#fff; font-weight:bold;}
    .right{text-align:right;}
    .nowrap{white-space:nowrap;}
    .bank{font-weight:600;}
    .device-action{display:flex; gap:4px; justify-content:center; align-items:center;}
    .device-action select{font-size:13px; padding:2px 4px;}
    #pagination { margin-top:10px; text-align:center; }
    #pagination button { margin:0 4px; }
    #pagination button.active { background:var(--green); }
    #refreshBtn {display: block;width: 100%;margin: 10px 0;padding: 10px;font-size: 16px;border-radius: 6px;}
    /* accounts pagination */
    #accountsPagination { margin-top:10px; text-align:center; }
    #accountsPagination button { margin:0 4px; }
    #accountsPagination button.active { background:var(--green); }
    .small-muted { font-size:12px; color:#666; margin-left:8px; }
  </style>
</head>
<body>

  <h2>Dashboard ‚Äì Game LC79</h2>

  <!-- ‚úÖ Box t·ªïng h·ª£p -->
  <div id="summaryBox" style="margin:12px 0; font-weight:bold; font-size:15px; background:#fff; padding:10px; border-radius:8px;">
    <p>T·ªïng N·∫°p: <span id="sumDeposit">0</span></p>
    <p>T·ªïng R√∫t: <span id="sumWithdraw">0</span></p>
    <p>S·ªë D∆∞: <span id="sumBalance">0</span></p>
    <p>L·ª£i Nhu·∫≠n: <span id="sumProfit">0</span></p>
  </div>

  <button id="refreshBtn" onclick="location.reload()">üîÑ Refresh</button>

  <!-- th√™m controls ph√¢n trang cho b·∫£ng ch√≠nh -->
  <div style="display:flex; justify-content:space-between; align-items:center; margin:8px 0;">
    <div>
      <label>Hi·ªÉn th·ªã: <strong>15</strong> d√≤ng / trang</label>
      <span class="small-muted"> (b·∫£ng t√†i kho·∫£n)</span>
    </div>
    <div id="accountsPagination" aria-label="Accounts pagination"></div>
  </div>

  <table id="tbl">
    <thead>
      <tr>
        <th>Game</th>
        <th>Username</th>
        <th>NickName</th>
        <th>Balance</th>
        <th>T·ªïng C∆∞·ª£c Ng√†y</th>
        <th>T·ªïng C∆∞·ª£c Tu·∫ßn</th>
        <th>T·ªïng C∆∞·ª£c Th√°ng</th>
        <th>T·ªïng N·∫°p</th>
        <th>T·ªïng R√∫t</th>
        <th>Ng√¢n h√†ng v√† STK</th>
        <th>Thi·∫øt B·ªã</th>
        <th>Proxy</th>
        <th>Access Token</th>
        <th>N·∫°p Ng√†y</th>
        <th>R√∫t Ng√†y</th>
        <th>Action</th>
        <th>Tr·∫°ng Th√°i</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
const fmt = n => (Number(n||0)).toLocaleString('vi-VN');

let profileMap = {};
let allDevices = [];
let historyData = [];
let userMap = {};
let totalsByUser = {}; // { username: { deposit, withdraw } }

// ====== Ph√¢n trang cho b·∫£ng l·ªãch s·ª≠ ======
let currentPage = 1;
const pageSize = 20;

// ====== Ph√¢n trang cho b·∫£ng t√†i kho·∫£n (m·ªõi) ======
let currentAccountPage = 1;
const accountPageSize = 15; // <- m·ªói trang 15 d√≤ng nh∆∞ b·∫°n y√™u c·∫ßu

// ================= INIT =================
async function init() {
  await loadProfiles();
  await loadDevices();
  await loadTotalsByUser();      // üÜï l·∫•y t·ªïng n·∫°p/r√∫t theo user t·ª´ backend (GROUP BY)
  await loadHistory();           // ch·ªâ ƒë·ªÉ hi·ªÉn th·ªã b·∫£ng l·ªãch s·ª≠ (kh√¥ng d√πng ƒë·ªÉ t√≠nh t·ªïng)
  await loadAccountsWithStats(); // render b·∫£ng ch√≠nh (b√¢y gi·ªù c√≥ ph√¢n trang)
}

// ================= LOAD PROFILES =================
async function loadProfiles() {
  try {
    const res = await fetch('/api/users');
    const arr = await res.json();
    profileMap = {};
    arr.forEach(p=>{
      profileMap[p.username] = { nickname: p.nickname || '', balance: Number(p.balance||0) };
    });
  } catch (e) {
    console.error('L·ªói load profiles:', e);
    profileMap = {};
  }
}

// ================= LOAD DEVICES =================
async function loadDevices() {
  try {
    const res = await fetch("/api/device-balances");
    allDevices = await res.json();
  } catch (err) {
    console.error("L·ªói khi load devices:", err);
    allDevices = [];
  }
}

// ================= LOAD TOTALS BY USER (API m·ªõi) =================
async function loadTotalsByUser() {
  try {
    const res = await fetch('/api/transactions/grouped/by-user');
    if (!res.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c t·ªïng n·∫°p/r√∫t');
    totalsByUser = await res.json() || {};
  } catch (e) {
    console.error('L·ªói loadTotalsByUser:', e);
    totalsByUser = {};
  }
}

// ================= LOAD ACCOUNTS + attach stats =================
async function loadAccountsWithStats() {
  try {
    const resAcc = await fetch('/api/accounts');
    const accounts = await resAcc.json();

    const resUsers = await fetch('/api/users');
    const users = await resUsers.json();

    const resBets = await fetch('/api/bet-history/stats/lc79/users');
    const betStats = await resBets.json();

    const betMap = {};
    (betStats?.stats || []).forEach(s => {
      betMap[s.username] = { 
        totalDay: s.totalDay, 
        totalWeek: s.totalWeek,
        totalMonth: s.totalMonth
      };
    });

    userMap = {};
    users.forEach(u => {
      userMap[u.username] = {
        status: u.status || "OFF Ng√†y",
        proxy: u.proxy || "",
        accessToken: u.accessToken || "",
        streak_win_today: Number(u.streak_win_today || 0),
        streak_lose_today: Number(u.streak_lose_today || 0),
      };
    });

    // N·∫°p ng√†y v·∫´n d·ª±a theo historyData (l·ªçc trong ng√†y)
    const todayDepositMap = buildTodayDepositMap();
    const todayWithdrawMap = buildTodayWithdrawMap();

    // G·∫Øn s·ªë li·ªáu v√†o accounts
    (accounts || []).forEach(acc => {
      acc.status = userMap[acc.username]?.status || "OFF Ng√†y";
      acc.proxy = userMap[acc.username]?.proxy || "";
      acc.accessToken = userMap[acc.username]?.accessToken || "";
      acc.totalBetDay = betMap[acc.username]?.totalDay || 0;
      acc.totalBetWeek = betMap[acc.username]?.totalWeek || 0;
      acc.totalBetMonth = betMap[acc.username]?.totalMonth || 0;
      acc.todayDeposit = todayDepositMap[acc.username] || 0;
      acc.todayWithdraw = todayWithdrawMap[acc.username] || 0;

      // ‚úÖ T·ªïng n·∫°p/r√∫t theo API GROUP BY (KH√îNG c√≤n ph·ª• thu·ªôc 100 b·∫£n ghi)
      acc.totalDeposit = totalsByUser[acc.username]?.deposit || 0;
      acc.totalWithdraw = totalsByUser[acc.username]?.withdraw || 0;
    });

    renderTable(accounts || []);
  } catch (err) {
    console.error("L·ªói khi load accounts:", err);
    renderTable([]);
  }
}

// ================= HELPERS =================
function bankCell(bank, accountNumber) {
  if (!bank && !accountNumber) return '<span class="muted">---</span>';
  if (bank && accountNumber) return `<span class="bank">${bank}</span> / <span>${accountNumber}</span>`;
  return `<span>${bank || accountNumber}</span>`;
}

function deviceEditable(username, value) {
  const safe = value || '---';
  return `<span class="editable-device" data-username="${username}">${safe}</span>`;
}

function statusSelect(username, status) {
  const valid = ['ƒêang Ch∆°i','Proxy L·ªói','Token L·ªói','H·∫øt Ti·ªÅn','OFF Ng√†y','M·ªõi T·∫°o','T·∫°m Ngh·ªâ','ƒê·ªß Ng√†y','ƒê·ªß Tu·∫ßn','ƒê·ªß Th√°ng'];
  const s = valid.includes(status) ? status : 'M·ªõi T·∫°o';
  const cls = [
    'status-select',
    (s === 'ƒêang Ch∆°i' ? 'playing' : ''),
    (['H·∫øt Ti·ªÅn', 'Proxy L·ªói', 'Token L·ªói'].includes(s) ? 'done' : '')
  ].join(' ');
  return `
    <select class="${cls}" data-username="${username}" onchange="updateStatus('${username}', this.value)">
      ${valid.map(o => `<option ${o===s ? 'selected' : ''}>${o}</option>`).join('')}
    </select>
  `;
}

// ================= RENDER MAIN TABLE =================
// B√¢y gi·ªù renderTable nh·∫≠n t·∫•t c·∫£ accounts, l·ªçc LC79, r·ªìi ph√¢n trang
function renderTable(rows) {
  const tbody = document.querySelector('#tbl tbody');
  tbody.innerHTML = '';

  // L·ªçc LC79
  const filtered = (rows || []).filter(r => (r.game||'').toUpperCase() === 'LC79');

  // ƒë·∫£m b·∫£o currentAccountPage n·∫±m trong gi·ªõi h·∫°n
  const totalPages = Math.max(1, Math.ceil(filtered.length / accountPageSize));
  if (currentAccountPage > totalPages) currentAccountPage = totalPages;
  if (currentAccountPage < 1) currentAccountPage = 1;

  const start = (currentAccountPage - 1) * accountPageSize;
  const end = start + accountPageSize;
  const pageItems = filtered.slice(start, end);

  pageItems.forEach(r=>{
    const uname = r.username;
    const p = profileMap[uname] || {};
    tbody.insertAdjacentHTML('beforeend', `
      <tr style="background:${getRowColor(r.status)}">
        <td>${(r.game||'')}</td>
        <td class="nowrap">${uname}</td>
        <td>${p.nickname || ''}</td>
        <td class="right">${fmt(p.balance)}</td>
        <td class="right">${fmt(r.totalBetDay || 0)}</td>
        <td class="right">${fmt(r.totalBetWeek || 0)}</td>
        <td class="right">${fmt(r.totalBetMonth || 0)}</td>
        <td class="right">${fmt(r.totalDeposit)}</td>
        <td class="right">${fmt(r.totalWithdraw)}</td>
        <td>${bankCell(r.bank, r.accountNumber)}</td>
        <td>${deviceEditable(uname, r.device)}</td>
        <td>${proxyEditable(uname, r.proxy)}</td>
        <td>${tokenEditable(uname, r.accessToken)}</td>
        <td class="right">${fmt(r.todayDeposit||0)}</td>
        <td class="right">${fmt(r.todayWithdraw||0)}</td>
        <td><button onclick="forceCheck('${uname}')">Check</button></td>
        <td>${statusSelect(uname, r.status)}</td>
      </tr>
    `);
  });

  // c·∫≠p nh·∫≠t ph√¢n trang cho b·∫£ng accounts
  renderAccountsPagination(filtered.length, totalPages, currentAccountPage);

  renderSummary(rows);
}

function renderAccountsPagination(totalItems, totalPages, currentPageLocal) {
  const container = document.getElementById('accountsPagination');
  container.innerHTML = '';

  // n·∫øu kh√¥ng c·∫ßn ph√¢n trang th√¨ gi·ªØ tr·ªëng
  if (totalPages <= 1) {
    container.innerHTML = `<span class="small-muted">T·ªïng ${totalItems} t√†i kho·∫£n</span>`;
    return;
  }

  const firstBtn = document.createElement('button');
  firstBtn.innerText = '<<';
  firstBtn.disabled = currentPageLocal === 1;
  firstBtn.addEventListener('click', () => { currentAccountPage = 1; renderTableFromCurrent(); });
  container.appendChild(firstBtn);

  const prevBtn = document.createElement('button');
  prevBtn.innerText = '<';
  prevBtn.disabled = currentPageLocal === 1;
  prevBtn.addEventListener('click', () => { currentAccountPage = Math.max(1, currentAccountPage - 1); renderTableFromCurrent(); });
  container.appendChild(prevBtn);

  // show s·ªë trang (gi√£n n·∫øu qu√° nhi·ªÅu)
  const maxButtons = 7;
  let start = Math.max(1, currentPageLocal - Math.floor(maxButtons/2));
  let finish = Math.min(totalPages, start + maxButtons - 1);
  if (finish - start < maxButtons - 1) start = Math.max(1, finish - maxButtons + 1);

  for (let i = start; i <= finish; i++) {
    const b = document.createElement('button');
    b.innerText = i;
    if (i === currentPageLocal) b.classList.add('active');
    b.addEventListener('click', () => { currentAccountPage = i; renderTableFromCurrent(); });
    container.appendChild(b);
  }

  const nextBtn = document.createElement('button');
  nextBtn.innerText = '>';
  nextBtn.disabled = currentPageLocal === totalPages;
  nextBtn.addEventListener('click', () => { currentAccountPage = Math.min(totalPages, currentAccountPage + 1); renderTableFromCurrent(); });
  container.appendChild(nextBtn);

  const lastBtn = document.createElement('button');
  lastBtn.innerText = '>>';
  lastBtn.disabled = currentPageLocal === totalPages;
  lastBtn.addEventListener('click', () => { currentAccountPage = totalPages; renderTableFromCurrent(); });
  container.appendChild(lastBtn);

  // th√™m t·ªïng
  const info = document.createElement('span');
  info.className = 'small-muted';
  info.innerText = ` T·ªïng ${totalItems} t√†i kho·∫£n - Trang ${currentPageLocal}/${totalPages}`;
  container.appendChild(info);
}

function renderTableFromCurrent() {
  // loadAccountsWithStats s·∫Ω g·ªçi renderTable khi ho√†n t·∫•t; nh∆∞ng ·ªü ƒë√¢y ch√∫ng ta ƒë√£ c√≥ d·ªØ li·ªáu hi·ªán t·∫°i,
  // n√™n ch·ªâ g·ªçi l·∫°i renderTable v·ªõi d·ªØ li·ªáu hi·ªán c√≥: fetch l·∫°i /api/accounts ƒë·ªÉ ƒë·ªìng b·ªô t·ªët h∆°n.
  // Tuy nhi√™n ƒë·ªÉ ƒë∆°n gi·∫£n v√† nhanh, g·ªçi loadAccountsWithStats ƒë·ªÉ ƒë·∫£m b·∫£o m·ªçi d·ªØ li·ªáu c·∫≠p nh·∫≠t.
  loadAccountsWithStats();
}

// ================= SUMMARY (d√πng totalsByUser) =================
function renderSummary(rows) {
  try {
    // 1) T·ªïng n·∫°p/r√∫t to√†n h·ªá th·ªëng t·ª´ totalsByUser (ƒë√£ GROUP BY ·ªü backend)
    let sumDeposit = 0, sumWithdraw = 0;
    Object.values(totalsByUser).forEach(v => {
      sumDeposit  += Number(v?.deposit  || 0);
      sumWithdraw += Number(v?.withdraw || 0);
    });

    // 2) T·ªïng s·ªë d∆∞: c·ªông balance c·ªßa c√°c account LC79 ƒëang render (t·∫•t c·∫£, kh√¥ng ch·ªâ 1 trang)
    let sumBalance = 0;
    rows
      .filter(r => (r.game || '').toUpperCase() === 'LC79')
      .forEach(r => {
        sumBalance += Number(profileMap[r.username]?.balance || 0);
      });

    // 3) L·ª£i nhu·∫≠n = R√∫t + S·ªë D∆∞ - N·∫°p
    const profit = sumWithdraw + sumBalance - sumDeposit;

    // 4) C·∫≠p nh·∫≠t UI
    document.getElementById("sumDeposit").innerText  = sumDeposit.toLocaleString('vi-VN');
    document.getElementById("sumWithdraw").innerText = sumWithdraw.toLocaleString('vi-VN');
    document.getElementById("sumBalance").innerText  = sumBalance.toLocaleString('vi-VN');
    document.getElementById("sumProfit").innerText   = profit.toLocaleString('vi-VN');
  } catch (err) {
    console.error("L·ªói renderSummary:", err);
  }
}

// ================= EDITABLE CELLS =================
function proxyEditable(username, value) {
  const safe = value || '---';
  return `<span class="editable-proxy" data-username="${username}">${safe}</span>`;
}

function formatStreak(um) {
  const w = Number(um?.streak_win_today || 0);
  const l = Number(um?.streak_lose_today || 0);
  return `${w}/${l}`;
}
function getRowColor(status) {
  switch (status) {
    case 'H·∫øt Ti·ªÅn': return '#ffb3b3';     // ƒë·ªè nh·∫°t
    case 'ƒêang Ch∆°i': return '#b3ffcc';    // xanh nh·∫°t
    case 'Proxy L·ªói':
    case 'Token L·ªói': return '#ff6666';    // üî¥ ƒë·ªè ƒë·∫≠m
    case 'ƒê·ªß Ng√†y':   return '#e6ccff';      // üíú t√≠m nh·∫°t
    case 'ƒê·ªß Th√°ng':  return '#000000';    // üÜï M√ÄU ƒêEN
    case 'ƒê·ªß Tu·∫ßn':   return '#fff3b0';     // üåü v√†ng nh·∫°t
    default: return '#ffffff';              // tr·∫Øng
  }
}

function tokenEditable(username, value) {
  const safe = value || '---';
  return `<span class="editable-token" data-username="${username}">${safe}</span>`;
}

// ================= ACTIONS =================
async function deposit(username) {
  const val = parseInt(document.getElementById(`deposit-${username}`).value, 10);
  const fromDevice = document.getElementById(`depositDevice-${username}`).value;
  if (!val || val <= 0 || !fromDevice) {
    return alert('Nh·∫≠p s·ªë ti·ªÅn h·ª£p l·ªá v√† ch·ªçn Device n·∫°p');
  }
  await fetch('/api/accounts/deposit', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ username, amount: val, fromDevice })
  });
  await loadDevices();
  await init();
}

// X√°c nh·∫≠n c·∫≠p nh·∫≠t device cho giao d·ªãch
async function confirmTxnDevice(transactionId) {
  const selectEl = document.getElementById(`txnDevice-${transactionId}`);
  const device = selectEl.value;
  if (!device) return alert("Vui l√≤ng ch·ªçn device");

  try {
    const res = await fetch(`/api/transactions/${transactionId}/device`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ device })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error || "C·∫≠p nh·∫≠t thi·∫øt b·ªã th·∫•t b·∫°i");
    }

    // G·ªçi API tr·ª´ ti·ªÅn device (n·∫øu c√≥)
    await fetch(`/api/device-balances/${device}/deduct`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ amount: getTxnAmount(transactionId) })
    });

    await loadDevices();
    await loadHistory();
  } catch (e) {
    console.error(e);
    alert(e.message || "L·ªói khi c·∫≠p nh·∫≠t thi·∫øt b·ªã giao d·ªãch");
  }
}

function cancelTxnDevice() { loadHistory(); }

function getTxnAmount(transactionId) {
  const txn = historyData.find(t => t.transactionId === transactionId);
  return txn ? Number(txn.amount || 0) : 0;
}

async function withdraw(username) {
  const val = parseInt(document.getElementById(`withdraw-${username}`).value, 10);
  if (!val || val <= 0) return alert('Nh·∫≠p s·ªë ti·ªÅn h·ª£p l·ªá');
  await fetch('/api/accounts/withdraw', {
    method:'POST', headers:{'Content-Type':'application/json'},
    body: JSON.stringify({ username, amount: val })
  });
  await init();
}

async function updateStatus(username, status) {
  try {
    const res = await fetch(`/api/users/${username}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ status })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error || 'C·∫≠p nh·∫≠t tr·∫°ng th√°i th·∫•t b·∫°i');
    }
    await init();
  } catch (e) {
    console.error(e);
    alert(e.message || 'L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i');
  }
}

// ================= FORCE CHECK =================
async function forceCheck(username) {
  try {
    await fetch('/api/force-check', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username })
    });
    await init();
  } catch (err) {
    console.error('L·ªói khi force-check', err);
  }
}



function buildTodayDepositMap() {
  const now = new Date();
  const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const endOfDay = startOfDay + 24 * 60 * 60 * 1000;
  const todayMap = {};

  historyData.forEach(txn => {
    if (txn.type === "N·∫°p ti·ªÅn") {
      const t = new Date(txn.time).getTime();
      if (t >= startOfDay && t < endOfDay) {
        todayMap[txn.username] = (todayMap[txn.username] || 0) + Number(txn.amount || 0);
      }
    }
  });

  return todayMap;
}
function buildTodayWithdrawMap() {
  const now = new Date();
  const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime();
  const endOfDay = startOfDay + 24 * 60 * 60 * 1000;
  const todayWithdrawMap = {};

  historyData.forEach(txn => {
    if (txn.type === "R√∫t ti·ªÅn") {
      const t = new Date(txn.time).getTime();
      if (t >= startOfDay && t < endOfDay) {
        todayWithdrawMap[txn.username] = (todayWithdrawMap[txn.username] || 0) + Number(txn.amount || 0);
      }
    }
  });

  return todayWithdrawMap;
}

async function updateTxnDevice(transactionId, device) {
  try {
    const res = await fetch(`/api/transactions/${transactionId}/device`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ device })
    });
    if (!res.ok) {
      const err = await res.json().catch(() => ({}));
      throw new Error(err?.error || 'C·∫≠p nh·∫≠t thi·∫øt b·ªã th·∫•t b·∫°i');
    }
    await loadHistory();
  } catch (e) {
    console.error(e);
    alert(e.message || 'L·ªói khi c·∫≠p nh·∫≠t thi·∫øt b·ªã giao d·ªãch');
  }
}

function renderHistoryPage(page) {
  const tbody = document.querySelector("#historyTable tbody");
  tbody.innerHTML = "";
  const start = (page - 1) * pageSize;
  const end = start + pageSize;
  const pageItems = historyData.slice(start, end);

  pageItems.forEach(txn => {
    let deviceCell = "";

    if (txn.type === "N·∫°p ti·ªÅn") {
      if (txn.device) {
        deviceCell = `<span>${txn.device}</span>`;
      } else {
        deviceCell = `
          <select id="txnDevice-${txn.transactionId}">
            <option value="">--Device--</option>
            ${allDevices.map(d => `
              <option value="${d.device}">
                ${d.device} (${(d.balance||0).toLocaleString('vi-VN')} ƒë)
              </option>
            `).join('')}
          </select>
          <button onclick="confirmTxnDevice('${txn.transactionId}')">‚úîÔ∏è</button>
          <button onclick="cancelTxnDevice('${txn.transactionId}')">‚ùå</button>
        `;
      }
    } else {
      deviceCell = `<span class="muted">---</span>`;
    }

    tbody.innerHTML += `
      <tr>
        <td>${txn.username}</td>
        <td>${txn.nickname || ''}</td>
        <td style="color:${txn.type === 'N·∫°p ti·ªÅn' ? 'red' : 'green'}; font-weight:bold;">
          ${txn.type}
        </td>
        <td class="right">${(txn.amount||0).toLocaleString('vi-VN')} ƒë</td>
        <td>${txn.transactionId || ''}</td>
        <td>${deviceCell}</td>
        <td>${txn.time}</td>
      </tr>
    `;
  });

  renderPagination();
}

function renderPagination() {
  const totalPages = Math.ceil(historyData.length / pageSize);
  const container = document.getElementById("pagination");
  container.innerHTML = "";
  for (let i = 1; i <= totalPages; i++) {
    const btn = document.createElement("button");
    btn.innerText = i;
    if (i === currentPage) btn.classList.add("active");
    btn.addEventListener("click", () => {
      currentPage = i;
      renderHistoryPage(currentPage);
    });
    container.appendChild(btn);
  }
}

// ================= INLINE EDIT DEVICE =================
document.addEventListener('click', function(e) {
  if (!e.target.classList.contains('editable-device')) return;

  const span = e.target;
  const username = span.dataset.username;
  const oldValue = span.innerText.trim();

  const input = document.createElement('input');
  input.type = 'text';
  input.value = (oldValue === '---') ? '' : oldValue;
  input.className = 'editable-input';

  span.replaceWith(input);
  input.focus();

  input.addEventListener('blur', async () => {
    const device = input.value.trim();
    try {
      if (device) {
        await fetch('/api/accounts/device', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, device })
        });
      }
      await loadAccountsWithStats();
    } catch (err) {
      console.error("L·ªói khi c·∫≠p nh·∫≠t device:", err);
      alert("C·∫≠p nh·∫≠t thi·∫øt b·ªã th·∫•t b·∫°i!");
      await loadAccountsWithStats();
    }
  });
});

// ================= INLINE EDIT PROXY =================
document.addEventListener('click', function(e) {
  if (!e.target.classList.contains('editable-proxy')) return;
  const span = e.target;
  const username = span.dataset.username;
  const oldValue = span.innerText.trim();
  const input = document.createElement('input');
  input.type = 'text';
  input.value = (oldValue === '---') ? '' : oldValue;
  input.className = 'editable-input';
  span.replaceWith(input);
  input.focus();

  input.addEventListener('blur', async ()=>{
    const proxy = input.value.trim();
    await fetch('/api/users/proxy', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ username, proxy })
    });
    await loadAccountsWithStats();
  });
});

// ================= INLINE EDIT TOKEN =================
document.addEventListener('click', function(e) {
  if (!e.target.classList.contains('editable-token')) return;
  const span = e.target;
  const username = span.dataset.username;
  const oldValue = span.innerText.trim();
  const input = document.createElement('input');
  input.type = 'text';
  input.value = (oldValue === '---') ? '' : oldValue;
  input.className = 'editable-input';
  span.replaceWith(input);
  input.focus();

  input.addEventListener('blur', async ()=>{
    const accessToken = input.value.trim();
    await fetch('/api/users/accessToken', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ username, accessToken })
    });
    await loadAccountsWithStats();
  });
});

init();
</script>
</body>
</html>
